// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResumeWithSlot = `-- name: CreateResumeWithSlot :one
insert into app.resumes (
  owner_user_id, slot, name, industry, yoe_bucket,
  pdf_storage_key, pdf_size_bytes, pdf_mime,
  image_key_prefix, page_count, image_ready
) values (
  $1, $2, $3, $4, $5,
  $6, $7, coalesce($8, 'application/pdf'),
  $9, coalesce($10, 1), coalesce($11, false)
)
returning id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
`

type CreateResumeWithSlotParams struct {
	OwnerUserID    pgtype.UUID
	Slot           int16
	Name           string
	Industry       string
	YoeBucket      string
	PdfStorageKey  pgtype.Text
	PdfSizeBytes   pgtype.Int8
	Column8        interface{}
	ImageKeyPrefix pgtype.Text
	Column10       interface{}
	Column11       interface{}
}

// Create ----------------------------------------------------------------
func (q *Queries) CreateResumeWithSlot(ctx context.Context, arg CreateResumeWithSlotParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, createResumeWithSlot,
		arg.OwnerUserID,
		arg.Slot,
		arg.Name,
		arg.Industry,
		arg.YoeBucket,
		arg.PdfStorageKey,
		arg.PdfSizeBytes,
		arg.Column8,
		arg.ImageKeyPrefix,
		arg.Column10,
		arg.Column11,
	)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const deleteResumeByIDForOwner = `-- name: DeleteResumeByIDForOwner :exec
delete from app.resumes
where id = $1 and owner_user_id = $2
`

type DeleteResumeByIDForOwnerParams struct {
	ID          pgtype.UUID
	OwnerUserID pgtype.UUID
}

// Delete ---------------------------------------------------------------
func (q *Queries) DeleteResumeByIDForOwner(ctx context.Context, arg DeleteResumeByIDForOwnerParams) error {
	_, err := q.db.Exec(ctx, deleteResumeByIDForOwner, arg.ID, arg.OwnerUserID)
	return err
}

const findFreeSlotForOwner = `-- name: FindFreeSlotForOwner :one

with slots as (select unnest(array[1,2,3])::smallint as slot)
select s.slot
from slots s
left join app.resumes r
  on r.owner_user_id = $1 and r.slot = s.slot
where r.id is null
order by s.slot
limit 1
`

// --------------------- START OF RESUME RELATED QUERIES ----------------------------------------
// Allocate a free slot (1..3) for an owner -------------------------------
func (q *Queries) FindFreeSlotForOwner(ctx context.Context, ownerUserID pgtype.UUID) (int16, error) {
	row := q.db.QueryRow(ctx, findFreeSlotForOwner, ownerUserID)
	var slot int16
	err := row.Scan(&slot)
	return slot, err
}

const getResumeByID = `-- name: GetResumeByID :one
select id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
from app.resumes
where id = $1
`

// Read ------------------------------------------------------------------
func (q *Queries) GetResumeByID(ctx context.Context, id pgtype.UUID) (AppResume, error) {
	row := q.db.QueryRow(ctx, getResumeByID, id)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const getResumeByIDForOwner = `-- name: GetResumeByIDForOwner :one
select id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
from app.resumes
where id = $1 and owner_user_id = $2
`

type GetResumeByIDForOwnerParams struct {
	ID          pgtype.UUID
	OwnerUserID pgtype.UUID
}

func (q *Queries) GetResumeByIDForOwner(ctx context.Context, arg GetResumeByIDForOwnerParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, getResumeByIDForOwner, arg.ID, arg.OwnerUserID)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const listOwnerSlots = `-- name: ListOwnerSlots :many
select slot
from app.resumes
where owner_user_id = $1
order by slot
`

// Convenience ----------------------------------------------------------
func (q *Queries) ListOwnerSlots(ctx context.Context, ownerUserID pgtype.UUID) ([]int16, error) {
	rows, err := q.db.Query(ctx, listOwnerSlots, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int16
	for rows.Next() {
		var slot int16
		if err := rows.Scan(&slot); err != nil {
			return nil, err
		}
		items = append(items, slot)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResumesByOwner = `-- name: ListResumesByOwner :many
select id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
from app.resumes
where owner_user_id = $1
order by created_at desc, id
limit $2 offset $3
`

type ListResumesByOwnerParams struct {
	OwnerUserID pgtype.UUID
	Limit       int32
	Offset      int32
}

func (q *Queries) ListResumesByOwner(ctx context.Context, arg ListResumesByOwnerParams) ([]AppResume, error) {
	rows, err := q.db.Query(ctx, listResumesByOwner, arg.OwnerUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppResume
	for rows.Next() {
		var i AppResume
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerUserID,
			&i.Industry,
			&i.YoeBucket,
			&i.CurrentEloInt,
			&i.BattlesCount,
			&i.LastMatchedAt,
			&i.InFlight,
			&i.CreatedAt,
			&i.PdfStorageKey,
			&i.PdfSizeBytes,
			&i.PdfMime,
			&i.ImageKeyPrefix,
			&i.PageCount,
			&i.ImageReady,
			&i.Slot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setResumeInFlight = `-- name: SetResumeInFlight :exec
update app.resumes
set in_flight = $3
where id = $1 and owner_user_id = $2
`

type SetResumeInFlightParams struct {
	ID          pgtype.UUID
	OwnerUserID pgtype.UUID
	InFlight    bool
}

func (q *Queries) SetResumeInFlight(ctx context.Context, arg SetResumeInFlightParams) error {
	_, err := q.db.Exec(ctx, setResumeInFlight, arg.ID, arg.OwnerUserID, arg.InFlight)
	return err
}

const updateResumeBuckets = `-- name: UpdateResumeBuckets :one
update app.resumes
set industry = $3,
    yoe_bucket = $4
where id = $1 and owner_user_id = $2
returning id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
`

type UpdateResumeBucketsParams struct {
	ID          pgtype.UUID
	OwnerUserID pgtype.UUID
	Industry    string
	YoeBucket   string
}

func (q *Queries) UpdateResumeBuckets(ctx context.Context, arg UpdateResumeBucketsParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, updateResumeBuckets,
		arg.ID,
		arg.OwnerUserID,
		arg.Industry,
		arg.YoeBucket,
	)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const updateResumeImageMeta = `-- name: UpdateResumeImageMeta :one
update app.resumes
set image_key_prefix = $3,
    image_ready = coalesce($4, image_ready)
where id = $1 and owner_user_id = $2
returning id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
`

type UpdateResumeImageMetaParams struct {
	ID             pgtype.UUID
	OwnerUserID    pgtype.UUID
	ImageKeyPrefix pgtype.Text
	ImageReady     bool
}

func (q *Queries) UpdateResumeImageMeta(ctx context.Context, arg UpdateResumeImageMetaParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, updateResumeImageMeta,
		arg.ID,
		arg.OwnerUserID,
		arg.ImageKeyPrefix,
		arg.ImageReady,
	)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const updateResumeName = `-- name: UpdateResumeName :one
update app.resumes
set name = $3
where id = $1 and owner_user_id = $2
returning id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
`

type UpdateResumeNameParams struct {
	ID          pgtype.UUID
	OwnerUserID pgtype.UUID
	Name        string
}

// Update ---------------------------------------------------------------
func (q *Queries) UpdateResumeName(ctx context.Context, arg UpdateResumeNameParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, updateResumeName, arg.ID, arg.OwnerUserID, arg.Name)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}

const updateResumePdfMeta = `-- name: UpdateResumePdfMeta :one
update app.resumes
set pdf_storage_key = $3,
    pdf_size_bytes = $4,
    pdf_mime = coalesce($5, pdf_mime)
where id = $1 and owner_user_id = $2
returning id, name, owner_user_id, industry, yoe_bucket, current_elo_int, battles_count, last_matched_at, in_flight, created_at, pdf_storage_key, pdf_size_bytes, pdf_mime, image_key_prefix, page_count, image_ready, slot
`

type UpdateResumePdfMetaParams struct {
	ID            pgtype.UUID
	OwnerUserID   pgtype.UUID
	PdfStorageKey pgtype.Text
	PdfSizeBytes  pgtype.Int8
	PdfMime       string
}

func (q *Queries) UpdateResumePdfMeta(ctx context.Context, arg UpdateResumePdfMetaParams) (AppResume, error) {
	row := q.db.QueryRow(ctx, updateResumePdfMeta,
		arg.ID,
		arg.OwnerUserID,
		arg.PdfStorageKey,
		arg.PdfSizeBytes,
		arg.PdfMime,
	)
	var i AppResume
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUserID,
		&i.Industry,
		&i.YoeBucket,
		&i.CurrentEloInt,
		&i.BattlesCount,
		&i.LastMatchedAt,
		&i.InFlight,
		&i.CreatedAt,
		&i.PdfStorageKey,
		&i.PdfSizeBytes,
		&i.PdfMime,
		&i.ImageKeyPrefix,
		&i.PageCount,
		&i.ImageReady,
		&i.Slot,
	)
	return i, err
}
